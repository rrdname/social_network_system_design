// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

// shard_key: user_id / key_based 
//            Плюсы: пользователи рапределяются равномерно по шардам.
//            Минусы: проблема с чтением списка и join'ами
// replica: master -> slave. 
// consistency: evential
// read mode: монотонное чтение. Каждый раз виден один и тот же профиль. Актуальность обновления не принципиальна.
//            Владелец профиля ходит на мастер для решения проблемы read after write
Table users {
  id integer [primary key]
  name varchar
  surname varchar
  description text
  registration_at timestamp
  last_visit_at timestamp
  city_id integer
  photo_media_id integer
}


// shard_key: user_id / key_based 
//            Плюсы: Посты равномерно рапределяются по шардам. 
//                   Для запроса списка постов пользователя ходим только на 1 шард.
//            Минусы: Чтение с разных реплик при отображении ленты новостей.
// replica: master -> slave. 
// consistency: evential
// read mode: монотонное чтение по user_id. Каждый раз виден один и тот же список постов.
Table posts {
  id integer [primary key]
  user_id integer
  text text
  created_at timestamp
  posts_hashtags_post_id integer
  files array[integer]
  views integer
  likes integer
}

// shard_key: hastag_id / key_based
//            Плюсы: Быстро определяется список постов по одному хештегу. 
//            Минусы: Если надо смотреть какие хештеги содержит пост, то надо сканить. 
//                   TODO: Лучше перенести список хештегов в таблицу posts, тогда проблема устранится.
// replica: master -> slave. 
// consistency: evential
// read mode: монотонное чтение по user владельца запроса.
Table posts_hastags {
  id integer [primary key]
  post_id integer
  hashtag_id integer
}


// shard_key: user_id / key_based
//            Плюсы: Т.к. пользователей много, у нас хорошее распределение постов по шардам. 
//                     Комментарии постов одного пользователя находятся на одном шарде, что упрощает чтение ленты постов.
//            Минусы:
// replica: master -> slave. 
// consistency: evential
// read mode: монотонное чтение по user_id. Если пользователь владелец запроса недавно редактировал посты user_id,
//            то перенаправляем его на master.
Table posts_comments {
  id integer [primary key]
  post_id integer
  user_id integer
  comment varchar
  reply_id integer
  created_at timestamp
  edited_at timestamp
}

Table hastags {
  id integer [primary key]
  hastag varchar
}


Table media {
   id integer
   link varchar
   type varchar
   extention varchar
   created_at timestamp
   user_id integer
}


Table chats {
   id integer
   created_at integer
   type enum(direct, group)
   name varchar
}

Table chat_participants {
   user_id integer
   chat_id integer
}


Table messages {
  id integer
  chat_id integer
  user_id integer
  message text
  created_at timestamp
  delivered_at timestamp
  viewed_at timestamp
  media_id integer
}

Table relationsips {
  user_id_from integer
  user_id_to integer
  type enum
  created_at integer
}

Ref: users.id < posts.user_id
Ref: users.photo_media_id - media.id
Ref: posts.files <> media.id
Ref: posts.posts_hashtags_post_id < posts_hastags.post_id
Ref: posts_hastags.hashtag_id > hastags.id
Ref: posts.id < posts_comments.post_id
Ref: chats.id < messages.chat_id
Ref: users.id < chat_participants.user_id
Ref: chat_participants.chat_id - chats.id
Ref: messages.media_id - media.id
Ref: users.id - relationsips.user_id_from
Ref: users.id - relationsips.user_id_to
